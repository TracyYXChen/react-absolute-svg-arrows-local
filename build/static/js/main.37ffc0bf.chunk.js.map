{"version":3,"sources":["utils/arrow-utils.ts","components/Arrow.tsx"],"names":["MAX_Y_CONTROL_POINT_SHIFT","calculateLowDyControlPointShift","dx","dy","maxShift","sign","value","Math","round","pow","abs","calculateControlPointsWithoutBoundingBox","absDx","absDy","leftTopX","leftTopY","rightBottomX","rightBottomY","fixedLineInflectionConstant","sqrt","calculateFixedLineInflectionConstant","lowDyYShift","lowDyXShift","p1","x","y","p2","p3","p4","Line","styled","svg","attrs","$xTranslate","$yTranslate","style","transform","$isHighlighted","CurvedLine","$showDebugGuideLines","$boundingBoxColor","RenderedLine","path","Endings","ArrowHeadEnding","DotEnding","circle","HoverableLine","HoverableDotEnding","ControlPoints","color","cx","cy","r","strokeWidth","fill","strokeDasharray","stroke","x1","y1","x2","y2","Arrow","startPoint","endPoint","isHighlighted","showDebugGuideLines","onMouseEnter","onMouseLeave","onClick","onMouseDown","config","tooltip","currentConfig","arrowColor","arrowHighlightedColor","controlPointsColor","boundingBoxColor","dotEndingBackground","dotEndingRadius","arrowHeadEndingSize","hoverableLineWidth","boundingBoxElementsBuffer","CONTROL_POINTS_RADIUS","calculateDeltas","topBorder","min","bottomBorder","max","leftBorder","verticalBuffer","horizontalBuffer","boundingBoxBuffer","vertical","horizontal","calculateControlPoints","canvasWidth","canvasHeight","calculateCanvasDimensions","canvasXOffset","canvasYOffset","curvedLinePath","getStrokeColor","markID","strokeColor","width","height","id","markerWidth","markerHeight","refX","refY","orient","points","d","markerEnd","pointerEvents"],"mappings":"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","file":"static/js/main.37ffc0bf.chunk.js","sourcesContent":["/**\n * Copyright (c) ProductBoard, Inc.\n * All rights reserved.\n */\n\nimport { Point } from \"../types/Point\";\n\nconst MAX_Y_CONTROL_POINT_SHIFT = 0;\nconst MAX_X_CONTROL_POINT_SHIFT = 0;\n\n// Y coordinates of our control points are moved in case of low delta Y to prevent lines overlapping.\n// Sign flips the curve depending on delta Y.\n// Movement is described according to following function: `y=a\\left(0.9^{1.2^{\\frac{x}{10}}}\\right)`\n//    1 +--------------------------------------------------------------------+\n//      |       ************** +           +          +           +          |\n//      |                     *******         1*(0.9**(1.2**(x/10))) ******* |\n//  0.8 |-+                          *****                                 +-|\n//      |                                ****                                |\n//      |                                    ****                            |\n//      |                                       ***                          |\n//  0.6 |-+                                        ***                     +-|\n//      |                                            ***                     |\n//      |                                              ***                   |\n//  0.4 |-+                                              ***               +-|\n//      |                                                   **               |\n//      |                                                     **             |\n//  0.2 |-+                                                     **         +-|\n//      |                                                         ***        |\n//      |                                                            ***     |\n//      |                                                               *****|\n//    0 |-+                                                                +-|\n//      |                                                                    |\n//      |           +          +           +          +           +          |\n// -0.2 +--------------------------------------------------------------------+\n// -100         -50         0           50        100         150        200\n//MAX_Y_CONTROL_POINT_SHIFT\nexport const calculateLowDyControlPointShift = (\n  dx: number,\n  dy: number,\n  maxShift = MAX_Y_CONTROL_POINT_SHIFT\n) => {\n  if (dx > 0) return 0;\n  const sign = dy < 0 ? -1 : 1;\n  const value = Math.round(\n    maxShift * Math.pow(0.9, Math.pow(1.2, Math.abs(dy) / 10))\n  );\n\n  // prevent negative zero\n  if (value === 0) return 0;\n\n  return sign * value;\n};\n\nexport const calculateDeltas = (\n  startPoint: Point,\n  endPoint: Point\n): {\n  dx: number;\n  dy: number;\n  absDx: number;\n  absDy: number;\n} => {\n  const dx = endPoint.x - startPoint.x;\n  const dy = endPoint.y - startPoint.y;\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n\n  return { dx, dy, absDx, absDy };\n};\n\nexport const calculateCanvasDimensions = ({\n  absDx,\n  absDy,\n  boundingBoxBuffer,\n}: {\n  absDx: number;\n  absDy: number;\n  boundingBoxBuffer: { vertical: number; horizontal: number };\n}): {\n  canvasWidth: number;\n  canvasHeight: number;\n} => {\n  const canvasWidth = absDx + 2 * boundingBoxBuffer.horizontal;\n  const canvasHeight = absDy + 2 * boundingBoxBuffer.vertical;\n\n  return { canvasWidth, canvasHeight };\n};\n\n// Curve flexure should remain on the same area no matter of absolute deltas, so we have to slightly shift X coordinates of our control points. It was created empirically, it's not based on a clear formula.\nexport const calculateFixedLineInflectionConstant = (\n  absDx: number,\n  absDy: number\n) => {\n  //X: 4, Y: 0.8\n  const WEIGHT_X = 0;\n  const WEIGHT_Y = 0;\n\n  return Math.round(Math.sqrt(absDx) * WEIGHT_X + Math.sqrt(absDy) * WEIGHT_Y);\n};\n\nexport const calculateControlPointsWithoutBoundingBox = ({\n  absDx,\n  absDy,\n  dx,\n  dy,\n}: {\n  absDx: number;\n  absDy: number;\n  dx: number;\n  dy: number;\n}): {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n} => {\n  let leftTopX = 0;\n  let leftTopY = 0;\n  let rightBottomX = absDx;\n  let rightBottomY = absDy;\n  if (dx < 0) [leftTopX, rightBottomX] = [rightBottomX, leftTopX];\n  if (dy < 0) [leftTopY, rightBottomY] = [rightBottomY, leftTopY];\n\n  const fixedLineInflectionConstant = calculateFixedLineInflectionConstant(\n    absDx,\n    absDy\n  );\n  const lowDyYShift = calculateLowDyControlPointShift(dx, dy);\n  const lowDyXShift = Math.abs(\n    calculateLowDyControlPointShift(dx, dy, MAX_X_CONTROL_POINT_SHIFT)\n  );\n\n  const p1 = {\n    x: leftTopX,\n    y: leftTopY,\n  };\n  const p2 = {\n    x: leftTopX + fixedLineInflectionConstant + lowDyXShift,\n    y: leftTopY + lowDyYShift,\n  };\n  const p3 = {\n    x: rightBottomX - fixedLineInflectionConstant - lowDyXShift,\n    y: rightBottomY - lowDyYShift,\n  };\n  const p4 = {\n    x: rightBottomX,\n    y: rightBottomY,\n  };\n\n  return { p1, p2, p3, p4 };\n};\nexport const calculateControlPoints = ({\n  boundingBoxElementsBuffer,\n  absDx,\n  absDy,\n  dx,\n  dy,\n}: {\n  boundingBoxElementsBuffer: number;\n  absDx: number;\n  absDy: number;\n  dx: number;\n  dy: number;\n}): {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n  boundingBoxBuffer: {\n    vertical: number;\n    horizontal: number;\n  };\n} => {\n  const { p1, p2, p3, p4 } = calculateControlPointsWithoutBoundingBox({\n    absDx,\n    absDy,\n    dx,\n    dy,\n  });\n\n  const topBorder = Math.min(p1.y, p2.y, p3.y, p4.y);\n  const bottomBorder = Math.max(p1.y, p2.y, p3.y, p4.y);\n  const leftBorder = Math.min(p1.x, p2.x, p3.x, p4.x);\n  const rightBorder = Math.max(p1.x, p2.x, p3.x, p4.x);\n\n  const verticalBuffer = \n    (bottomBorder - topBorder - absDy) / 2 + boundingBoxElementsBuffer;\n  const horizontalBuffer = \n    (rightBorder - leftBorder - absDx) / 2 + boundingBoxElementsBuffer;\n\n  const boundingBoxBuffer = {\n    vertical: verticalBuffer,\n    horizontal: horizontalBuffer,\n  };\n  //console.log(boundingBoxBuffer);\n\n  return {\n    p1: {\n      x: p1.x + horizontalBuffer,\n      y: p1.y + verticalBuffer,\n    },\n    p2: {\n      x: p2.x + horizontalBuffer,\n      y: p2.y + verticalBuffer,\n    },\n    p3: {\n      x: p3.x + horizontalBuffer,\n      y: p3.y + verticalBuffer,\n    },\n    p4: {\n      x: p4.x + horizontalBuffer,\n      y: p4.y + verticalBuffer,\n    },\n    boundingBoxBuffer,\n  };\n};\n","/**\n * Copyright (c) ProductBoard, Inc.\n * All rights reserved.\n */\nimport React from \"react\";\n\nimport styled from \"styled-components\";\n\nimport {\n  calculateDeltas,\n  calculateCanvasDimensions,\n  calculateControlPoints,\n} from \"../utils/arrow-utils\";\nimport { Point } from \"../types/Point\";\n\nconst CONTROL_POINTS_RADIUS = 5;\nconst STRAIGHT_LINE_BEFORE_ARROW_HEAD = 0;\n\ntype ArrowConfig = {\n  arrowColor?: string;\n  arrowHighlightedColor?: string;\n  controlPointsColor?: string;\n  boundingBoxColor?: string;\n  dotEndingBackground?: string;\n  dotEndingRadius?: number;\n  arrowHeadEndingSize?: number;\n  hoverableLineWidth?: number;\n  strokeWidth?: number;\n};\n\ntype Props = {\n  startPoint: Point;\n  endPoint: Point;\n  isHighlighted?: boolean;\n  showDebugGuideLines?: boolean;\n  onMouseEnter?: (e: React.MouseEvent) => void;\n  onMouseLeave?: (e: React.MouseEvent) => void;\n  onClick?: (e: React.MouseEvent) => void;\n  onMouseDown? : (e: React.MouseEvent) => void;\n  config?: ArrowConfig;\n  tooltip?: string;\n};\n\ntype TranslateProps = {\n  $xTranslate: number;\n  $yTranslate: number;\n};\n\ntype LineProps = {\n  $isHighlighted: boolean;\n  $showDebugGuideLines?: boolean;\n  $boundingBoxColor?: string;\n} & TranslateProps;\n\nconst Line = styled.svg.attrs(({ $xTranslate, $yTranslate }: LineProps) => ({\n  style: { transform: `translate(${$xTranslate}px, ${$yTranslate}px)` },\n}))<LineProps>`\n  pointer-events: none;\n  z-index: ${({ $isHighlighted }) => ($isHighlighted ? 2 : 1)};\n  position: absolute;\n  left: 0;\n  top: 0;\n`;\n\nconst CurvedLine = styled(Line)`\n  border: ${({ $showDebugGuideLines, $boundingBoxColor = \"black\" }) =>\n    $showDebugGuideLines ? `dashed 1px ${$boundingBoxColor}` : \"0\"};\n`;\n\nconst RenderedLine = styled.path`\n  transition: stroke 300ms;\n`;\n\nconst Endings = styled(Line)`\n  pointer-events: none;\n  z-index: ${({ $isHighlighted }) => ($isHighlighted ? 11 : 10)};\n`;\n\nconst ArrowHeadEnding = styled.path.attrs(\n  ({ $xTranslate, $yTranslate }: TranslateProps) => ({\n    style: { transform: `translate(${$xTranslate}px, ${$yTranslate}px)` },\n  })\n)<TranslateProps>`\n  transition: stroke 300ms;\n`;\n\nconst DotEnding = styled.circle`\n  transition: stroke 300ms;\n`;\n\nconst HoverableLine = styled.path`\n  cursor: default;\n`;\n\nconst HoverableArrowHeadEnding = styled(ArrowHeadEnding)`\n  cursor: default;\n`;\n\nconst HoverableDotEnding = styled.circle`\n  cursor: default;\n`;\n\nconst ControlPoints = ({\n  p1,\n  p2,\n  p3,\n  p4,\n  color,\n}: {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n  color: string;\n}) => {\n  return (\n    <>\n      <circle\n        cx={p2.x}\n        cy={p2.y}\n        r={CONTROL_POINTS_RADIUS}\n        strokeWidth=\"0\"\n        fill={color}\n      />\n      <circle\n        cx={p3.x}\n        cy={p3.y}\n        r={CONTROL_POINTS_RADIUS}\n        strokeWidth=\"0\"\n        fill={color}\n      />\n      <line\n        strokeDasharray=\"1,3\"\n        stroke={color}\n        x1={p1.x}\n        y1={p1.y}\n        x2={p2.x}\n        y2={p2.y}\n      />\n      <line\n        strokeDasharray=\"1,3\"\n        stroke={color}\n        x1={p3.x}\n        y1={p3.y}\n        x2={p4.x}\n        y2={p4.y}\n      />\n    </>\n  );\n};\n\nexport const Arrow = ({\n  startPoint,\n  endPoint,\n  isHighlighted = false,\n  showDebugGuideLines = false,\n  onMouseEnter,\n  onMouseLeave,\n  onClick,\n  onMouseDown,\n  config,\n  tooltip,\n}: Props) => {\n  //console.log(startPoint, endPoint);\n  const defaultConfig = {\n    //\"#bcc4cc\"\n    arrowColor: \"#bcc4cc\",\n    arrowHighlightedColor: \"#4da6ff\",\n    controlPointsColor: \"#ff4747\",\n    boundingBoxColor: \"#ffcccc\",\n    dotEndingBackground: \"#fff\",\n    dotEndingRadius: 3,\n    arrowHeadEndingSize: 29,\n    hoverableLineWidth: 15,\n    strokeWidth: 1,\n  };\n  const currentConfig = {\n    ...defaultConfig,\n    ...config,\n  };\n\n  const {\n    arrowColor,\n    arrowHighlightedColor,\n    controlPointsColor,\n    boundingBoxColor,\n    arrowHeadEndingSize,\n    strokeWidth,\n    hoverableLineWidth,\n    dotEndingBackground,\n    dotEndingRadius,\n  } = currentConfig;\n\n  const arrowHeadOffset = arrowHeadEndingSize / 2;\n  const boundingBoxElementsBuffer =\n    strokeWidth +\n    arrowHeadEndingSize / 2 +\n    dotEndingRadius +\n    CONTROL_POINTS_RADIUS / 2;\n\n  const { absDx, absDy, dx, dy } = calculateDeltas(startPoint, endPoint);\n  const { p1, p2, p3, p4, boundingBoxBuffer } = calculateControlPoints({\n    boundingBoxElementsBuffer,\n    dx,\n    dy,\n    absDx,\n    absDy,\n  });\n\n  const { canvasWidth, canvasHeight } = calculateCanvasDimensions({\n    absDx,\n    absDy,\n    boundingBoxBuffer,\n  });\n\n  const canvasXOffset =\n    Math.min(startPoint.x, endPoint.x) - boundingBoxBuffer.horizontal;\n  const canvasYOffset =\n    Math.min(startPoint.y, endPoint.y) - boundingBoxBuffer.vertical;\n\n  // const curvedLinePath = `\n  //   M ${p1.x} ${p1.y}\n  //   C ${p2.x} ${p2.y},\n  //   ${p3.x} ${p3.y},\n  //   ${p4.x - STRAIGHT_LINE_BEFORE_ARROW_HEAD} ${p4.y}\n  //   L ${p4.x} ${p4.y}`;\n  \n  const curvedLinePath = `\n    M ${p1.x} ${p1.y}\n    L ${p4.x} ${p4.y}`;\n\n\n  //console.log(curvedLinePath);\n  //console.log(startPoint.x, startPoint.y, endPoint.x, endPoint.y);\n  const getStrokeColor = () => {\n    if (isHighlighted) return arrowHighlightedColor;\n\n    return arrowColor;\n  };\n\n  //console.log(\"p4\", p4.x, p4.y);\n  //console.log(\"end point\", endPoint.x, endPoint.y);\n  const markID = `arrowhead-${startPoint.x}-${startPoint.y}-${endPoint.x}-${endPoint.y}`;\n  const strokeColor = getStrokeColor();\n  //console.log(markID);\n\n  return (\n    <>\n      <CurvedLine\n        width={canvasWidth}\n        height={canvasHeight}\n        $isHighlighted={isHighlighted}\n        $showDebugGuideLines={showDebugGuideLines}\n        $boundingBoxColor={boundingBoxColor}\n        $xTranslate={canvasXOffset}\n        $yTranslate={canvasYOffset}\n      >\n        <defs>\n        <marker id={markID} markerWidth=\"10\" markerHeight=\"7\" \n          refX=\"0\" refY=\"3.5\" orient=\"auto\">\n            <polygon points=\"0 0, 10 3.5, 0 7\" fill={arrowColor}/>\n        </marker>\n        </defs> \n         \n        {/* <line x1={startPoint.x} y1={startPoint.y} x2={endPoint.x} y2={endPoint.y} stroke={getStrokeColor()} \n        strokeWidth={strokeWidth} markerEnd={`url(#${markID})`} />  */}\n        <RenderedLine\n          d={curvedLinePath}\n          //d={`M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`}\n          strokeWidth={strokeWidth}\n          stroke={getStrokeColor()}\n          fill=\"yellow\"\n          markerEnd={`url(#${markID})`}\n        /> \n      \n       \n        <HoverableLine\n          d={curvedLinePath}\n          //d={`M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`}\n          strokeWidth={hoverableLineWidth}\n          stroke=\"transparent\"\n          pointerEvents=\"all\"\n          fill=\"green\"\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n          onMouseDown={onMouseDown}\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableLine>\n        {/* <HoverableArrowHeadEnding\n          d={arrowPath}\n          fill=\"none\"\n          stroke=\"transparent\"\n          strokeWidth={hoverableLineWidth}\n          strokeLinecap=\"round\"\n          pointerEvents=\"all\"\n          $xTranslate={p4.x - arrowHeadOffset * 2}\n          $yTranslate={p4.y - arrowHeadOffset}\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n          onMouseDown={onMouseDown}\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableArrowHeadEnding> */}\n        <HoverableDotEnding\n          cx={p1.x}\n          cy={p1.y}\n          r={dotEndingRadius}\n          stroke=\"transparent\"\n          strokeWidth={hoverableLineWidth}\n          fill=\"transparent\"\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableDotEnding>\n      </CurvedLine>\n\n      <Endings\n        width={canvasWidth}\n        height={canvasHeight}\n        $isHighlighted={isHighlighted}\n        $xTranslate={canvasXOffset}\n        $yTranslate={canvasYOffset}\n      >\n        <DotEnding\n          cx={p1.x}\n          cy={p1.y}\n          r={dotEndingRadius}\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          fill={dotEndingBackground}\n        />\n        {/* <ArrowHeadEnding\n          d={arrowPath}\n          fill=\"none\"\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          strokeLinecap=\"round\"\n          //$xTranslate={p4.x - arrowHeadOffset * 2}\n          //$yTranslate={p4.y - arrowHeadOffset}\n          $xTranslate={p4.x - arrowHeadOffset * 2}\n          $yTranslate={p4.y - arrowHeadOffset}\n        /> */}\n        \n        {/* <line x1={startPoint.x} y1={startPoint.y} x2={endPoint.x} y2={endPoint.y} stroke=\"black\" \n        strokeWidth={strokeWidth} markerEnd={`url(#${markID})`} />  */}\n        \n        {showDebugGuideLines && (\n          <ControlPoints\n            p1={p1}\n            p2={p2}\n            p3={p3}\n            p4={p4}\n            color={controlPointsColor}\n          />\n        )}\n      </Endings>\n    </>\n  );\n};\n"],"sourceRoot":""}