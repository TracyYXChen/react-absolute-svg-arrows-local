{"version":3,"sources":["utils/arrow-utils.ts","components/Arrow.tsx"],"names":["MAX_Y_CONTROL_POINT_SHIFT","calculateLowDyControlPointShift","dx","dy","maxShift","sign","value","Math","round","pow","abs","calculateControlPointsWithoutBoundingBox","absDx","absDy","leftTopX","leftTopY","rightBottomX","rightBottomY","fixedLineInflectionConstant","sqrt","calculateFixedLineInflectionConstant","lowDyYShift","lowDyXShift","p1","x","y","p2","p3","p4","Line","styled","svg","attrs","$xTranslate","$yTranslate","style","transform","$isHighlighted","CurvedLine","$showDebugGuideLines","$boundingBoxColor","RenderedLine","path","Endings","ArrowHeadEnding","DotEnding","circle","HoverableLine","HoverableArrowHeadEnding","HoverableDotEnding","ControlPoints","color","cx","cy","r","strokeWidth","fill","strokeDasharray","stroke","x1","y1","x2","y2","Arrow","startPoint","endPoint","isHighlighted","showDebugGuideLines","onMouseEnter","onMouseLeave","onClick","onMouseDown","config","tooltip","console","log","currentConfig","arrowColor","arrowHighlightedColor","controlPointsColor","boundingBoxColor","dotEndingBackground","dotEndingRadius","arrowHeadEndingSize","hoverableLineWidth","arrowHeadOffset","boundingBoxElementsBuffer","CONTROL_POINTS_RADIUS","calculateDeltas","topBorder","min","bottomBorder","max","leftBorder","verticalBuffer","horizontalBuffer","boundingBoxBuffer","vertical","horizontal","calculateControlPoints","canvasWidth","canvasHeight","calculateCanvasDimensions","canvasXOffset","canvasYOffset","curvedLinePath","getStrokeColor","arrDir","k","arrowPath","strokeColor","width","height","d","pointerEvents","strokeLinecap"],"mappings":"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","file":"static/js/main.21d131ba.chunk.js","sourcesContent":["/**\n * Copyright (c) ProductBoard, Inc.\n * All rights reserved.\n */\n\nimport { Point } from \"../types/Point\";\n\nconst MAX_Y_CONTROL_POINT_SHIFT = 0;\nconst MAX_X_CONTROL_POINT_SHIFT = 10;\n\n// Y coordinates of our control points are moved in case of low delta Y to prevent lines overlapping.\n// Sign flips the curve depending on delta Y.\n// Movement is described according to following function: `y=a\\left(0.9^{1.2^{\\frac{x}{10}}}\\right)`\n//    1 +--------------------------------------------------------------------+\n//      |       ************** +           +          +           +          |\n//      |                     *******         1*(0.9**(1.2**(x/10))) ******* |\n//  0.8 |-+                          *****                                 +-|\n//      |                                ****                                |\n//      |                                    ****                            |\n//      |                                       ***                          |\n//  0.6 |-+                                        ***                     +-|\n//      |                                            ***                     |\n//      |                                              ***                   |\n//  0.4 |-+                                              ***               +-|\n//      |                                                   **               |\n//      |                                                     **             |\n//  0.2 |-+                                                     **         +-|\n//      |                                                         ***        |\n//      |                                                            ***     |\n//      |                                                               *****|\n//    0 |-+                                                                +-|\n//      |                                                                    |\n//      |           +          +           +          +           +          |\n// -0.2 +--------------------------------------------------------------------+\n// -100         -50         0           50        100         150        200\n//MAX_Y_CONTROL_POINT_SHIFT\nexport const calculateLowDyControlPointShift = (\n  dx: number,\n  dy: number,\n  maxShift = MAX_Y_CONTROL_POINT_SHIFT\n) => {\n  if (dx > 0) return 0;\n  const sign = dy < 0 ? -1 : 1;\n  const value = Math.round(\n    maxShift * Math.pow(0.9, Math.pow(1.2, Math.abs(dy) / 10))\n  );\n\n  // prevent negative zero\n  if (value === 0) return 0;\n\n  return sign * value;\n};\n\nexport const calculateDeltas = (\n  startPoint: Point,\n  endPoint: Point\n): {\n  dx: number;\n  dy: number;\n  absDx: number;\n  absDy: number;\n} => {\n  const dx = endPoint.x - startPoint.x;\n  const dy = endPoint.y - startPoint.y;\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n\n  return { dx, dy, absDx, absDy };\n};\n\nexport const calculateCanvasDimensions = ({\n  absDx,\n  absDy,\n  boundingBoxBuffer,\n}: {\n  absDx: number;\n  absDy: number;\n  boundingBoxBuffer: { vertical: number; horizontal: number };\n}): {\n  canvasWidth: number;\n  canvasHeight: number;\n} => {\n  const canvasWidth = absDx + 2 * boundingBoxBuffer.horizontal;\n  const canvasHeight = absDy + 2 * boundingBoxBuffer.vertical;\n\n  return { canvasWidth, canvasHeight };\n};\n\n// Curve flexure should remain on the same area no matter of absolute deltas, so we have to slightly shift X coordinates of our control points. It was created empirically, it's not based on a clear formula.\nexport const calculateFixedLineInflectionConstant = (\n  absDx: number,\n  absDy: number\n) => {\n  //X: 4, Y: 0.8\n  const WEIGHT_X = 0;\n  const WEIGHT_Y = 0;\n\n  return Math.round(Math.sqrt(absDx) * WEIGHT_X + Math.sqrt(absDy) * WEIGHT_Y);\n};\n\nexport const calculateControlPointsWithoutBoundingBox = ({\n  absDx,\n  absDy,\n  dx,\n  dy,\n}: {\n  absDx: number;\n  absDy: number;\n  dx: number;\n  dy: number;\n}): {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n} => {\n  let leftTopX = 0;\n  let leftTopY = 0;\n  let rightBottomX = absDx;\n  let rightBottomY = absDy;\n  if (dx < 0) [leftTopX, rightBottomX] = [rightBottomX, leftTopX];\n  if (dy < 0) [leftTopY, rightBottomY] = [rightBottomY, leftTopY];\n\n  const fixedLineInflectionConstant = calculateFixedLineInflectionConstant(\n    absDx,\n    absDy\n  );\n  const lowDyYShift = calculateLowDyControlPointShift(dx, dy);\n  const lowDyXShift = Math.abs(\n    calculateLowDyControlPointShift(dx, dy, MAX_X_CONTROL_POINT_SHIFT)\n  );\n\n  const p1 = {\n    x: leftTopX,\n    y: leftTopY,\n  };\n  const p2 = {\n    x: leftTopX + fixedLineInflectionConstant + lowDyXShift,\n    y: leftTopY + lowDyYShift,\n  };\n  const p3 = {\n    x: rightBottomX - fixedLineInflectionConstant - lowDyXShift,\n    y: rightBottomY - lowDyYShift,\n  };\n  const p4 = {\n    x: rightBottomX,\n    y: rightBottomY,\n  };\n\n  return { p1, p2, p3, p4 };\n};\nexport const calculateControlPoints = ({\n  boundingBoxElementsBuffer,\n  absDx,\n  absDy,\n  dx,\n  dy,\n}: {\n  boundingBoxElementsBuffer: number;\n  absDx: number;\n  absDy: number;\n  dx: number;\n  dy: number;\n}): {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n  boundingBoxBuffer: {\n    vertical: number;\n    horizontal: number;\n  };\n} => {\n  const { p1, p2, p3, p4 } = calculateControlPointsWithoutBoundingBox({\n    absDx,\n    absDy,\n    dx,\n    dy,\n  });\n\n  const topBorder = Math.min(p1.y, p2.y, p3.y, p4.y);\n  const bottomBorder = Math.max(p1.y, p2.y, p3.y, p4.y);\n  const leftBorder = Math.min(p1.x, p2.x, p3.x, p4.x);\n  const rightBorder = Math.max(p1.x, p2.x, p3.x, p4.x);\n\n  const verticalBuffer = \n    (bottomBorder - topBorder - absDy) / 2 + boundingBoxElementsBuffer;\n  const horizontalBuffer = \n    (rightBorder - leftBorder - absDx) / 2 + boundingBoxElementsBuffer;\n\n  const boundingBoxBuffer = {\n    vertical: verticalBuffer,\n    horizontal: horizontalBuffer,\n  };\n  //console.log(boundingBoxBuffer);\n\n  return {\n    p1: {\n      x: p1.x + horizontalBuffer,\n      y: p1.y + verticalBuffer,\n    },\n    p2: {\n      x: p2.x + horizontalBuffer,\n      y: p2.y + verticalBuffer,\n    },\n    p3: {\n      x: p3.x + horizontalBuffer,\n      y: p3.y + verticalBuffer,\n    },\n    p4: {\n      x: p4.x + horizontalBuffer,\n      y: p4.y + verticalBuffer,\n    },\n    boundingBoxBuffer,\n  };\n};\n","/**\n * Copyright (c) ProductBoard, Inc.\n * All rights reserved.\n */\nimport React from \"react\";\n\nimport styled from \"styled-components\";\n\nimport {\n  calculateDeltas,\n  calculateCanvasDimensions,\n  calculateControlPoints,\n} from \"../utils/arrow-utils\";\nimport { Point } from \"../types/Point\";\n\nconst CONTROL_POINTS_RADIUS = 5;\nconst STRAIGHT_LINE_BEFORE_ARROW_HEAD = 5;\n\ntype ArrowConfig = {\n  arrowColor?: string;\n  arrowHighlightedColor?: string;\n  controlPointsColor?: string;\n  boundingBoxColor?: string;\n  dotEndingBackground?: string;\n  dotEndingRadius?: number;\n  arrowHeadEndingSize?: number;\n  hoverableLineWidth?: number;\n  strokeWidth?: number;\n};\n\ntype Props = {\n  startPoint: Point;\n  endPoint: Point;\n  isHighlighted?: boolean;\n  showDebugGuideLines?: boolean;\n  onMouseEnter?: (e: React.MouseEvent) => void;\n  onMouseLeave?: (e: React.MouseEvent) => void;\n  onClick?: (e: React.MouseEvent) => void;\n  onMouseDown? : (e: React.MouseEvent) => void;\n  config?: ArrowConfig;\n  tooltip?: string;\n};\n\ntype TranslateProps = {\n  $xTranslate: number;\n  $yTranslate: number;\n};\n\ntype LineProps = {\n  $isHighlighted: boolean;\n  $showDebugGuideLines?: boolean;\n  $boundingBoxColor?: string;\n} & TranslateProps;\n\nconst Line = styled.svg.attrs(({ $xTranslate, $yTranslate }: LineProps) => ({\n  style: { transform: `translate(${$xTranslate}px, ${$yTranslate}px)` },\n}))<LineProps>`\n  pointer-events: none;\n  z-index: ${({ $isHighlighted }) => ($isHighlighted ? 2 : 1)};\n  position: absolute;\n  left: 0;\n  top: 0;\n`;\n\nconst CurvedLine = styled(Line)`\n  border: ${({ $showDebugGuideLines, $boundingBoxColor = \"black\" }) =>\n    $showDebugGuideLines ? `dashed 1px ${$boundingBoxColor}` : \"0\"};\n`;\n\nconst RenderedLine = styled.path`\n  transition: stroke 300ms;\n`;\n\nconst Endings = styled(Line)`\n  pointer-events: none;\n  z-index: ${({ $isHighlighted }) => ($isHighlighted ? 11 : 10)};\n`;\n\nconst ArrowHeadEnding = styled.path.attrs(\n  ({ $xTranslate, $yTranslate }: TranslateProps) => ({\n    style: { transform: `translate(${$xTranslate}px, ${$yTranslate}px)` },\n  })\n)<TranslateProps>`\n  transition: stroke 300ms;\n`;\n\nconst DotEnding = styled.circle`\n  transition: stroke 300ms;\n`;\n\nconst HoverableLine = styled.path`\n  cursor: default;\n`;\n\nconst HoverableArrowHeadEnding = styled(ArrowHeadEnding)`\n  cursor: default;\n`;\n\nconst HoverableDotEnding = styled.circle`\n  cursor: default;\n`;\n\nconst ControlPoints = ({\n  p1,\n  p2,\n  p3,\n  p4,\n  color,\n}: {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n  color: string;\n}) => {\n  return (\n    <>\n      <circle\n        cx={p2.x}\n        cy={p2.y}\n        r={CONTROL_POINTS_RADIUS}\n        strokeWidth=\"0\"\n        fill={color}\n      />\n      <circle\n        cx={p3.x}\n        cy={p3.y}\n        r={CONTROL_POINTS_RADIUS}\n        strokeWidth=\"0\"\n        fill={color}\n      />\n      <line\n        strokeDasharray=\"1,3\"\n        stroke={color}\n        x1={p1.x}\n        y1={p1.y}\n        x2={p2.x}\n        y2={p2.y}\n      />\n      <line\n        strokeDasharray=\"1,3\"\n        stroke={color}\n        x1={p3.x}\n        y1={p3.y}\n        x2={p4.x}\n        y2={p4.y}\n      />\n    </>\n  );\n};\n\nexport const Arrow = ({\n  startPoint,\n  endPoint,\n  isHighlighted = false,\n  showDebugGuideLines = false,\n  onMouseEnter,\n  onMouseLeave,\n  onClick,\n  onMouseDown,\n  config,\n  tooltip,\n}: Props) => {\n  console.log(startPoint, endPoint);\n  const defaultConfig = {\n    //\"#bcc4cc\"\n    arrowColor: 'red',\n    arrowHighlightedColor: \"#4da6ff\",\n    controlPointsColor: \"#ff4747\",\n    boundingBoxColor: \"#ffcccc\",\n    dotEndingBackground: \"#fff\",\n    dotEndingRadius: 3,\n    arrowHeadEndingSize: 29,\n    hoverableLineWidth: 15,\n    strokeWidth: 1,\n  };\n  const currentConfig = {\n    ...defaultConfig,\n    ...config,\n  };\n\n  const {\n    arrowColor,\n    arrowHighlightedColor,\n    controlPointsColor,\n    boundingBoxColor,\n    arrowHeadEndingSize,\n    strokeWidth,\n    hoverableLineWidth,\n    dotEndingBackground,\n    dotEndingRadius,\n  } = currentConfig;\n\n  const arrowHeadOffset = arrowHeadEndingSize / 2;\n  const boundingBoxElementsBuffer =\n    strokeWidth +\n    arrowHeadEndingSize / 2 +\n    dotEndingRadius +\n    CONTROL_POINTS_RADIUS / 2;\n\n  const { absDx, absDy, dx, dy } = calculateDeltas(startPoint, endPoint);\n  const { p1, p2, p3, p4, boundingBoxBuffer } = calculateControlPoints({\n    boundingBoxElementsBuffer,\n    dx,\n    dy,\n    absDx,\n    absDy,\n  });\n\n  const { canvasWidth, canvasHeight } = calculateCanvasDimensions({\n    absDx,\n    absDy,\n    boundingBoxBuffer,\n  });\n\n  const canvasXOffset =\n    Math.min(startPoint.x, endPoint.x) - boundingBoxBuffer.horizontal;\n  const canvasYOffset =\n    Math.min(startPoint.y, endPoint.y) - boundingBoxBuffer.vertical;\n\n  const curvedLinePath = `\n    M ${p1.x} ${p1.y}\n    C ${p2.x} ${p2.y},\n    ${p3.x} ${p3.y},\n    ${p4.x - STRAIGHT_LINE_BEFORE_ARROW_HEAD} ${p4.y}\n    L ${p4.x} ${p4.y}`;\n\n  const getStrokeColor = () => {\n    if (isHighlighted) return arrowHighlightedColor;\n\n    return arrowColor;\n  };\n\n  //pick an arrow direction\n\n  let arrDir = '';\n  if (startPoint.y === endPoint.y) {\n      if (startPoint.x < endPoint.x) {\n          arrDir = 'right';\n      }\n      else {\n          arrDir = 'left';\n      }\n  }\n\n  //the axis is upward and rightward\n  let k = (endPoint.y - startPoint.y) / (endPoint.x - startPoint.x);\n  if (k < -1 || k > 1) {\n    if (endPoint.y > startPoint.y) {\n      arrDir = 'down'\n    }\n    else {\n      arrDir = 'up'\n    }\n  }\n  else {\n    if (endPoint.x > startPoint.x) {\n      arrDir = 'right'\n    }\n    else {\n      arrDir = 'left'\n    }\n  }\n  \n  let arrowPath = '';\n  if(arrDir === 'up') {\n    arrowPath = `M ${0}  ${arrowHeadEndingSize}\n      L ${arrowHeadEndingSize * 4 / 5 } ${arrowHeadEndingSize * 2 / 5} \n      L ${arrowHeadEndingSize * 8 / 5} ${arrowHeadEndingSize}`;\n  }\n  else if(arrDir === 'down') {\n    arrowPath = `M ${0}  ${arrowHeadEndingSize * 2 / 5}\n    L ${arrowHeadEndingSize * 4 / 5 } ${arrowHeadEndingSize * 3 / 5} \n    L ${arrowHeadEndingSize * 8 / 5} ${arrowHeadEndingSize * 2 / 5}`;\n  }\n  else if(arrDir === 'right') {\n    arrowPath = `M ${(arrowHeadEndingSize / 5) * 4} 0\n      L ${arrowHeadEndingSize} ${arrowHeadEndingSize / 2}\n      L ${(arrowHeadEndingSize / 5) * 4} ${arrowHeadEndingSize}`;\n  }\n  else if(arrDir === 'left') {\n    arrowPath = `M ${arrowHeadEndingSize * 6 / 5 } 0\n      L ${arrowHeadEndingSize * 4 / 5} ${arrowHeadEndingSize / 2}\n      L ${arrowHeadEndingSize * 6 / 5 } ${arrowHeadEndingSize}`;\n  }\n  console.log(\"p4\", p4.x, p4.y);\n  console.log(\"end point\", endPoint.x, endPoint.y);\n\n  const strokeColor = getStrokeColor();\n\n  return (\n    <>\n      <CurvedLine\n        width={canvasWidth}\n        height={canvasHeight}\n        $isHighlighted={isHighlighted}\n        $showDebugGuideLines={showDebugGuideLines}\n        $boundingBoxColor={boundingBoxColor}\n        $xTranslate={canvasXOffset}\n        $yTranslate={canvasYOffset}\n      >\n        <RenderedLine\n          d={curvedLinePath}\n          strokeWidth={strokeWidth}\n          stroke={getStrokeColor()}\n          fill=\"none\"\n        />\n        <HoverableLine\n          d={curvedLinePath}\n          strokeWidth={hoverableLineWidth}\n          stroke=\"transparent\"\n          pointerEvents=\"all\"\n          fill=\"none\"\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n          onMouseDown={onMouseDown}\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableLine>\n        <HoverableArrowHeadEnding\n          d={arrowPath}\n          fill=\"none\"\n          stroke=\"transparent\"\n          strokeWidth={hoverableLineWidth}\n          strokeLinecap=\"round\"\n          pointerEvents=\"all\"\n          $xTranslate={p4.x - arrowHeadOffset * 2}\n          $yTranslate={p4.y - arrowHeadOffset}\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n          onMouseDown={onMouseDown}\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableArrowHeadEnding>\n        <HoverableDotEnding\n          cx={p1.x}\n          cy={p1.y}\n          r={dotEndingRadius}\n          stroke=\"transparent\"\n          strokeWidth={hoverableLineWidth}\n          fill=\"transparent\"\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableDotEnding>\n      </CurvedLine>\n      <Endings\n        width={canvasWidth}\n        height={canvasHeight}\n        $isHighlighted={isHighlighted}\n        $xTranslate={canvasXOffset}\n        $yTranslate={canvasYOffset}\n      >\n        <DotEnding\n          cx={p1.x}\n          cy={p1.y}\n          r={dotEndingRadius}\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          fill={dotEndingBackground}\n        />\n        <ArrowHeadEnding\n          d={arrowPath}\n          fill=\"none\"\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          strokeLinecap=\"round\"\n          //$xTranslate={p4.x - arrowHeadOffset * 2}\n          //$yTranslate={p4.y - arrowHeadOffset}\n          $xTranslate={p4.x - arrowHeadOffset * 2}\n          $yTranslate={p4.y - arrowHeadOffset}\n        />\n        {showDebugGuideLines && (\n          <ControlPoints\n            p1={p1}\n            p2={p2}\n            p3={p3}\n            p4={p4}\n            color={controlPointsColor}\n          />\n        )}\n      </Endings>\n    </>\n  );\n};\n"],"sourceRoot":""}