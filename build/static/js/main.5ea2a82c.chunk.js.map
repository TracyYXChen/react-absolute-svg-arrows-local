{"version":3,"sources":["utils/arrow-utils.ts","components/Arrow.tsx"],"names":["calculateLowDyControlPointShift","dx","dy","maxShift","sign","value","Math","round","pow","abs","calculateControlPointsWithoutBoundingBox","absDx","absDy","leftTopX","leftTopY","rightBottomX","rightBottomY","fixedLineInflectionConstant","sqrt","calculateFixedLineInflectionConstant","lowDyYShift","lowDyXShift","p1","x","y","p2","p3","p4","Line","styled","svg","attrs","$xTranslate","$yTranslate","style","transform","$isHighlighted","CurvedLine","$showDebugGuideLines","$boundingBoxColor","RenderedLine","path","Endings","ArrowHeadEnding","DotEnding","circle","HoverableLine","HoverableArrowHeadEnding","HoverableDotEnding","ControlPoints","color","cx","cy","r","strokeWidth","fill","strokeDasharray","stroke","x1","y1","x2","y2","Arrow","startPoint","endPoint","isHighlighted","showDebugGuideLines","onMouseEnter","onMouseLeave","onClick","config","tooltip","currentConfig","arrowColor","arrowHighlightedColor","controlPointsColor","boundingBoxColor","dotEndingBackground","dotEndingRadius","arrowHeadEndingSize","hoverableLineWidth","arrowHeadOffset","boundingBoxElementsBuffer","CONTROL_POINTS_RADIUS","calculateDeltas","topBorder","min","bottomBorder","max","leftBorder","verticalBuffer","horizontalBuffer","boundingBoxBuffer","vertical","horizontal","calculateControlPoints","canvasWidth","canvasHeight","calculateCanvasDimensions","canvasXOffset","canvasYOffset","curvedLinePath","getStrokeColor","strokeColor","width","height","d","pointerEvents","strokeLinecap"],"mappings":"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","file":"static/js/main.5ea2a82c.chunk.js","sourcesContent":["/**\n * Copyright (c) ProductBoard, Inc.\n * All rights reserved.\n */\n\nimport { Point } from \"../types/Point\";\n\nconst MAX_Y_CONTROL_POINT_SHIFT = 50;\nconst MAX_X_CONTROL_POINT_SHIFT = 10;\n\n// Y coordinates of our control points are moved in case of low delta Y to prevent lines overlapping.\n// Sign flips the curve depending on delta Y.\n// Movement is described according to following function: `y=a\\left(0.9^{1.2^{\\frac{x}{10}}}\\right)`\n//    1 +--------------------------------------------------------------------+\n//      |       ************** +           +          +           +          |\n//      |                     *******         1*(0.9**(1.2**(x/10))) ******* |\n//  0.8 |-+                          *****                                 +-|\n//      |                                ****                                |\n//      |                                    ****                            |\n//      |                                       ***                          |\n//  0.6 |-+                                        ***                     +-|\n//      |                                            ***                     |\n//      |                                              ***                   |\n//  0.4 |-+                                              ***               +-|\n//      |                                                   **               |\n//      |                                                     **             |\n//  0.2 |-+                                                     **         +-|\n//      |                                                         ***        |\n//      |                                                            ***     |\n//      |                                                               *****|\n//    0 |-+                                                                +-|\n//      |                                                                    |\n//      |           +          +           +          +           +          |\n// -0.2 +--------------------------------------------------------------------+\n// -100         -50         0           50        100         150        200\nexport const calculateLowDyControlPointShift = (\n  dx: number,\n  dy: number,\n  maxShift = MAX_Y_CONTROL_POINT_SHIFT\n) => {\n  if (dx > 0) return 0;\n  const sign = dy < 0 ? -1 : 1;\n  const value = Math.round(\n    maxShift * Math.pow(0.9, Math.pow(1.2, Math.abs(dy) / 10))\n  );\n\n  // prevent negative zero\n  if (value === 0) return 0;\n\n  return sign * value;\n};\n\nexport const calculateDeltas = (\n  startPoint: Point,\n  endPoint: Point\n): {\n  dx: number;\n  dy: number;\n  absDx: number;\n  absDy: number;\n} => {\n  const dx = endPoint.x - startPoint.x;\n  const dy = endPoint.y - startPoint.y;\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n\n  return { dx, dy, absDx, absDy };\n};\n\nexport const calculateCanvasDimensions = ({\n  absDx,\n  absDy,\n  boundingBoxBuffer,\n}: {\n  absDx: number;\n  absDy: number;\n  boundingBoxBuffer: { vertical: number; horizontal: number };\n}): {\n  canvasWidth: number;\n  canvasHeight: number;\n} => {\n  const canvasWidth = absDx + 2 * boundingBoxBuffer.horizontal;\n  const canvasHeight = absDy + 2 * boundingBoxBuffer.vertical;\n\n  return { canvasWidth, canvasHeight };\n};\n\n// Curve flexure should remain on the same area no matter of absolute deltas, so we have to slightly shift X coordinates of our control points. It was created empirically, it's not based on a clear formula.\nexport const calculateFixedLineInflectionConstant = (\n  absDx: number,\n  absDy: number\n) => {\n  const WEIGHT_X = 4;\n  const WEIGHT_Y = 0.8;\n\n  return Math.round(Math.sqrt(absDx) * WEIGHT_X + Math.sqrt(absDy) * WEIGHT_Y);\n};\n\nexport const calculateControlPointsWithoutBoundingBox = ({\n  absDx,\n  absDy,\n  dx,\n  dy,\n}: {\n  absDx: number;\n  absDy: number;\n  dx: number;\n  dy: number;\n}): {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n} => {\n  let leftTopX = 0;\n  let leftTopY = 0;\n  let rightBottomX = absDx;\n  let rightBottomY = absDy;\n  if (dx < 0) [leftTopX, rightBottomX] = [rightBottomX, leftTopX];\n  if (dy < 0) [leftTopY, rightBottomY] = [rightBottomY, leftTopY];\n\n  const fixedLineInflectionConstant = calculateFixedLineInflectionConstant(\n    absDx,\n    absDy\n  );\n  const lowDyYShift = calculateLowDyControlPointShift(dx, dy);\n  const lowDyXShift = Math.abs(\n    calculateLowDyControlPointShift(dx, dy, MAX_X_CONTROL_POINT_SHIFT)\n  );\n\n  const p1 = {\n    x: leftTopX,\n    y: leftTopY,\n  };\n  const p2 = {\n    x: leftTopX + fixedLineInflectionConstant + lowDyXShift,\n    y: leftTopY + lowDyYShift,\n  };\n  const p3 = {\n    x: rightBottomX - fixedLineInflectionConstant - lowDyXShift,\n    y: rightBottomY - lowDyYShift,\n  };\n  const p4 = {\n    x: rightBottomX,\n    y: rightBottomY,\n  };\n\n  return { p1, p2, p3, p4 };\n};\nexport const calculateControlPoints = ({\n  boundingBoxElementsBuffer,\n  absDx,\n  absDy,\n  dx,\n  dy,\n}: {\n  boundingBoxElementsBuffer: number;\n  absDx: number;\n  absDy: number;\n  dx: number;\n  dy: number;\n}): {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n  boundingBoxBuffer: {\n    vertical: number;\n    horizontal: number;\n  };\n} => {\n  const { p1, p2, p3, p4 } = calculateControlPointsWithoutBoundingBox({\n    absDx,\n    absDy,\n    dx,\n    dy,\n  });\n\n  const topBorder = Math.min(p1.y, p2.y, p3.y, p4.y);\n  const bottomBorder = Math.max(p1.y, p2.y, p3.y, p4.y);\n  const leftBorder = Math.min(p1.x, p2.x, p3.x, p4.x);\n  const rightBorder = Math.max(p1.x, p2.x, p3.x, p4.x);\n\n  const verticalBuffer =\n    (bottomBorder - topBorder - absDy) / 2 + boundingBoxElementsBuffer;\n  const horizontalBuffer =\n    (rightBorder - leftBorder - absDx) / 2 + boundingBoxElementsBuffer;\n\n  const boundingBoxBuffer = {\n    vertical: verticalBuffer,\n    horizontal: horizontalBuffer,\n  };\n\n  return {\n    p1: {\n      x: p1.x + horizontalBuffer,\n      y: p1.y + verticalBuffer,\n    },\n    p2: {\n      x: p2.x + horizontalBuffer,\n      y: p2.y + verticalBuffer,\n    },\n    p3: {\n      x: p3.x + horizontalBuffer,\n      y: p3.y + verticalBuffer,\n    },\n    p4: {\n      x: p4.x + horizontalBuffer,\n      y: p4.y + verticalBuffer,\n    },\n    boundingBoxBuffer,\n  };\n};\n","/**\n * Copyright (c) ProductBoard, Inc.\n * All rights reserved.\n */\nimport React from \"react\";\n\nimport styled from \"styled-components\";\n\nimport {\n  calculateDeltas,\n  calculateCanvasDimensions,\n  calculateControlPoints,\n} from \"../utils/arrow-utils\";\nimport { Point } from \"../types/Point\";\n\nconst CONTROL_POINTS_RADIUS = 5;\nconst STRAIGHT_LINE_BEFORE_ARROW_HEAD = 5;\n\ntype ArrowConfig = {\n  arrowColor?: string;\n  arrowHighlightedColor?: string;\n  controlPointsColor?: string;\n  boundingBoxColor?: string;\n  dotEndingBackground?: string;\n  dotEndingRadius?: number;\n  arrowHeadEndingSize?: number;\n  hoverableLineWidth?: number;\n  strokeWidth?: number;\n};\n\ntype Props = {\n  startPoint: Point;\n  endPoint: Point;\n  isHighlighted?: boolean;\n  showDebugGuideLines?: boolean;\n  onMouseEnter?: (e: React.MouseEvent) => void;\n  onMouseLeave?: (e: React.MouseEvent) => void;\n  onClick?: (e: React.MouseEvent) => void;\n  config?: ArrowConfig;\n  tooltip?: string;\n};\n\ntype TooltipProps = {\n  children: string;\n  \n};\n\ntype TranslateProps = {\n  $xTranslate: number;\n  $yTranslate: number;\n};\n\ntype LineProps = {\n  $isHighlighted: boolean;\n  $showDebugGuideLines?: boolean;\n  $boundingBoxColor?: string;\n} & TranslateProps;\n\nconst Line = styled.svg.attrs(({ $xTranslate, $yTranslate }: LineProps) => ({\n  style: { transform: `translate(${$xTranslate}px, ${$yTranslate}px)` },\n}))<LineProps>`\n  pointer-events: none;\n  z-index: ${({ $isHighlighted }) => ($isHighlighted ? 2 : 1)};\n  position: absolute;\n  left: 0;\n  top: 0;\n`;\n\nconst CurvedLine = styled(Line)`\n  border: ${({ $showDebugGuideLines, $boundingBoxColor = \"black\" }) =>\n    $showDebugGuideLines ? `dashed 1px ${$boundingBoxColor}` : \"0\"};\n`;\n\nconst RenderedLine = styled.path`\n  transition: stroke 300ms;\n`;\n\nconst Endings = styled(Line)`\n  pointer-events: none;\n  z-index: ${({ $isHighlighted }) => ($isHighlighted ? 11 : 10)};\n`;\n\nconst ArrowHeadEnding = styled.path.attrs(\n  ({ $xTranslate, $yTranslate }: TranslateProps) => ({\n    style: { transform: `translate(${$xTranslate}px, ${$yTranslate}px)` },\n  })\n)<TranslateProps>`\n  transition: stroke 300ms;\n`;\n\nconst DotEnding = styled.circle`\n  transition: stroke 300ms;\n`;\n\nconst HoverableLine = styled.path`\n  cursor: default;\n`;\n\nconst HoverableArrowHeadEnding = styled(ArrowHeadEnding)`\n  cursor: default;\n`;\n\nconst HoverableDotEnding = styled.circle`\n  cursor: default;\n`;\n\nconst ControlPoints = ({\n  p1,\n  p2,\n  p3,\n  p4,\n  color,\n}: {\n  p1: Point;\n  p2: Point;\n  p3: Point;\n  p4: Point;\n  color: string;\n}) => {\n  return (\n    <>\n      <circle\n        cx={p2.x}\n        cy={p2.y}\n        r={CONTROL_POINTS_RADIUS}\n        strokeWidth=\"0\"\n        fill={color}\n      />\n      <circle\n        cx={p3.x}\n        cy={p3.y}\n        r={CONTROL_POINTS_RADIUS}\n        strokeWidth=\"0\"\n        fill={color}\n      />\n      <line\n        strokeDasharray=\"1,3\"\n        stroke={color}\n        x1={p1.x}\n        y1={p1.y}\n        x2={p2.x}\n        y2={p2.y}\n      />\n      <line\n        strokeDasharray=\"1,3\"\n        stroke={color}\n        x1={p3.x}\n        y1={p3.y}\n        x2={p4.x}\n        y2={p4.y}\n      />\n    </>\n  );\n};\n\nexport const Arrow = ({\n  startPoint,\n  endPoint,\n  isHighlighted = false,\n  showDebugGuideLines = false,\n  onMouseEnter,\n  onMouseLeave,\n  onClick,\n  config,\n  tooltip,\n}: Props) => {\n  const defaultConfig = {\n    arrowColor: \"#bcc4cc\",\n    arrowHighlightedColor: \"#4da6ff\",\n    controlPointsColor: \"#ff4747\",\n    boundingBoxColor: \"#ffcccc\",\n    dotEndingBackground: \"#fff\",\n    dotEndingRadius: 3,\n    arrowHeadEndingSize: 9,\n    hoverableLineWidth: 15,\n    strokeWidth: 1,\n  };\n  const currentConfig = {\n    ...defaultConfig,\n    ...config,\n  };\n\n  const {\n    arrowColor,\n    arrowHighlightedColor,\n    controlPointsColor,\n    boundingBoxColor,\n    arrowHeadEndingSize,\n    strokeWidth,\n    hoverableLineWidth,\n    dotEndingBackground,\n    dotEndingRadius,\n  } = currentConfig;\n\n  const arrowHeadOffset = arrowHeadEndingSize / 2;\n  const boundingBoxElementsBuffer =\n    strokeWidth +\n    arrowHeadEndingSize / 2 +\n    dotEndingRadius +\n    CONTROL_POINTS_RADIUS / 2;\n\n  const { absDx, absDy, dx, dy } = calculateDeltas(startPoint, endPoint);\n  const { p1, p2, p3, p4, boundingBoxBuffer } = calculateControlPoints({\n    boundingBoxElementsBuffer,\n    dx,\n    dy,\n    absDx,\n    absDy,\n  });\n\n  const { canvasWidth, canvasHeight } = calculateCanvasDimensions({\n    absDx,\n    absDy,\n    boundingBoxBuffer,\n  });\n\n  const canvasXOffset =\n    Math.min(startPoint.x, endPoint.x) - boundingBoxBuffer.horizontal;\n  const canvasYOffset =\n    Math.min(startPoint.y, endPoint.y) - boundingBoxBuffer.vertical;\n\n  const curvedLinePath = `\n    M ${p1.x} ${p1.y}\n    C ${p2.x} ${p2.y},\n    ${p3.x} ${p3.y},\n    ${p4.x - STRAIGHT_LINE_BEFORE_ARROW_HEAD} ${p4.y}\n    L ${p4.x} ${p4.y}`;\n\n  const getStrokeColor = () => {\n    if (isHighlighted) return arrowHighlightedColor;\n\n    return arrowColor;\n  };\n\n  const strokeColor = getStrokeColor();\n\n  return (\n    <>\n      <CurvedLine\n        width={canvasWidth}\n        height={canvasHeight}\n        $isHighlighted={isHighlighted}\n        $showDebugGuideLines={showDebugGuideLines}\n        $boundingBoxColor={boundingBoxColor}\n        $xTranslate={canvasXOffset}\n        $yTranslate={canvasYOffset}\n      >\n        <RenderedLine\n          d={curvedLinePath}\n          strokeWidth={strokeWidth}\n          stroke={getStrokeColor()}\n          fill=\"none\"\n        />\n        <HoverableLine\n          d={curvedLinePath}\n          strokeWidth={hoverableLineWidth}\n          stroke=\"transparent\"\n          pointerEvents=\"all\"\n          fill=\"none\"\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableLine>\n        <HoverableArrowHeadEnding\n          d={`\n            M ${(arrowHeadEndingSize / 5) * 2} 0\n            L ${arrowHeadEndingSize} ${arrowHeadEndingSize / 2}\n            L ${(arrowHeadEndingSize / 5) * 2} ${arrowHeadEndingSize}`}\n          fill=\"none\"\n          stroke=\"transparent\"\n          strokeWidth={hoverableLineWidth}\n          strokeLinecap=\"round\"\n          pointerEvents=\"all\"\n          $xTranslate={p4.x - arrowHeadOffset * 2}\n          $yTranslate={p4.y - arrowHeadOffset}\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          onClick={onClick}\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableArrowHeadEnding>\n        <HoverableDotEnding\n          cx={p1.x}\n          cy={p1.y}\n          r={dotEndingRadius}\n          stroke=\"transparent\"\n          strokeWidth={hoverableLineWidth}\n          fill=\"transparent\"\n        >\n          {tooltip && <title>{tooltip}</title>}\n        </HoverableDotEnding>\n      </CurvedLine>\n      <Endings\n        width={canvasWidth}\n        height={canvasHeight}\n        $isHighlighted={isHighlighted}\n        $xTranslate={canvasXOffset}\n        $yTranslate={canvasYOffset}\n      >\n        <DotEnding\n          cx={p1.x}\n          cy={p1.y}\n          r={dotEndingRadius}\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          fill={dotEndingBackground}\n        />\n        <ArrowHeadEnding\n          d={`\n            M ${(arrowHeadEndingSize / 5) * 2} 0\n            L ${arrowHeadEndingSize} ${arrowHeadEndingSize / 2}\n            L ${(arrowHeadEndingSize / 5) * 2} ${arrowHeadEndingSize}`}\n          fill=\"none\"\n          stroke={strokeColor}\n          strokeWidth={strokeWidth}\n          strokeLinecap=\"round\"\n          $xTranslate={p4.x - arrowHeadOffset * 2}\n          $yTranslate={p4.y - arrowHeadOffset}\n        />\n        {showDebugGuideLines && (\n          <ControlPoints\n            p1={p1}\n            p2={p2}\n            p3={p3}\n            p4={p4}\n            color={controlPointsColor}\n          />\n        )}\n      </Endings>\n    </>\n  );\n};\n"],"sourceRoot":""}